<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>BuckleScript</title>

    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">

    <!-- Optional theme -->
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap-theme.min.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/styles/default.min.css">
    <script src="js/highlight.pack.js"></script>

    <!-- Custom CSS -->
    <link href="css/simple-sidebar.css" rel="stylesheet">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

</head>

<body>

    <div id="wrapper">

        <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
              <p><strong><a href="index.html">Home</a></strong></p>
<p><strong><a href="https://bloomberg.github.io/bucklescript/js-demo">Playground</a></strong></p>
<p><strong>Get Started</strong></p>
<ul>
<li><a href="Installation.html">Installation</a></li>
<li><a href="Create-a-simple-example-with-NPM.html">Create a simple example with NPM</a></li>
</ul>
<p><strong>BuckleScript Basics</strong></p>
<ul>
<li><a href="FAQ.html">FAQ</a></li>
<li><a href="https://ocaml.org/">About OCaml</a></li>
<li><a href="Compiler-options.html">Compiler options</a></li>
<li><a href="How-to-adapt-your-build-system.html">How to adapt your build system</a></li>
<li><a href="Extensions-to-OCaml-Language.html">Extensions to OCaml Language</a></li>
<li><a href="Semantic-differences-from-other-backends.html">Semantic differences from other backends</a></li>
<li><a href="JavaScript-target-versions.html">JavaScript target versions</a></li>
</ul>
<p><strong>BuckleScript Overview</strong></p>
<ul>
<li><a href="Compiler-overview.html">Compiler overview</a></li>
</ul>
<p><strong>BuckleScript FFI</strong></p>
<ul>
<li><a href="Runtime-representation.html">Runtime representation</a></li>
<li><a href="Curry-and-Uncurry-functions.html">Curry and Uncurry functions</a></li>
<li><a href="JS-call-OCaml.html">JS call OCaml</a></li>
<li><a href="OCaml-call-JS.html">OCaml call JS</a></li>
<li><a href="Experimental-support-of-typescript.html">Experimental support of typescript</a></li>
<li><a href="Unsupported-IO-primitives.html">Unsupported IO primitives</a></li>
</ul>
<p><strong>Contributions</strong></p>
<ul>
<li><a href="https://github.com/bloomberg/bucklescript">Github Link</a></li>
<li><a href="Dev-mode-How-to.html">Dev mode How to</a></li>
<li><a href="Help-move-runtime-functions-from-OCaml-to-Javascript.html">Help move runtime functions from OCaml to Javascript</a></li>
</ul>
<p><strong>Roadmap</strong></p>
<ul>
<li><a href="Roadmap.html">Roadmap</a></li>
</ul>
<p><strong>Comparisons</strong></p>
<ul>
<li><a href="Differences-from-js_of_ocaml.html">Differences from js_of_ocaml</a></li>
</ul>

            </ul>
        </div>
        <!-- /#sidebar-wrapper -->

        <!-- Page Content -->
        <div id="page-content-wrapper">
            <div class="container-fluid">
                <div class="row">

                    <div class="col-lg-12">
                      <a  class="btn btn-default"
                      id="menu-toggle" 
                         >Toggle Menu</a>

                      <a  href="https://github.com/bloomberg/bucklescript/tree/master/docs/Differences-from-js_of_ocaml.md" class="btn btn-default"
                      style="position: absolute; top: 0; right: 0;
                      border: 0;"
                         >Edit on Github</a>

                      <p><a href="https://github.com/ocsigen/js_of_ocaml">js_of_ocaml</a> is a popular compiler which compiles OCaml&#39;s bytecode into JavaScript. It is the inspiration for this project, and has already been under development for several years and is ready for production. In comparison, BuckleScript, while moving fast, is still a very young project. BuckleScript&#39;s motivation, like <code>js_of_ocaml</code>, is to unify the ubiquity of the JavaScript platform and the truly sophisticated type system of OCaml, however, there are some areas where we view things differently from <code>js_of_ocaml</code>. We describe below, some of these differences, and also refer readers to some of the original informal <a href="https://github.com/ocsigen/js_of_ocaml/issues/338">discussions</a>.</p>
<h2 id="debuggable-output">Debuggable Output</h2>
<p>One of the main BuckleScript goal is to generate debuggable JavaScript code. From the start we believed developers using BuckleScript for JavaScript development will look at the generated code an order of magnitude more than an OCaml developer will look at the assembly one. Part of our intent is to make it easier for a JavaScript developer to transition to the OCaml language. Furthermore looking at existing transpilers for JavaScript:  <a href="http://coffeescript.org/">coffescript</a>, <a href="https://babeljs.io/">babel</a> and <a href="https://github.com/Microsoft/TypeScript">typescript</a>, the most widely adopted ones are the one that favors code readability.
The generated code by BuckleScript is pretty close to the JavaScript code one might write by hand, especially if you use mostly the language features which are shared between JavaScript and OCaml. </p>
<p><code>js_of_ocaml</code> produces code with mangled names, which is typically not a concern, except when the code is used as a primary backend and must be extensively debugged and maintained. In these situations, <code>js_of_ocaml</code> proves harder to debug, because the original names in the code are lost.</p>
<h2 id="runtime-representations-ffi">Runtime Representations &amp;&amp; FFI</h2>
<p><strong>Runtime Representation</strong></p>
<p><code>js_of_ocaml</code> runtime representation is as close as possible to the runtime representation of native/byte compiler. This makes it particularly easy for an OCaml developer already familiar with that representation. </p>
<p>BuckleScript runtime representation is closer to JavaScript. This is particularly helpful for both the ability to debug OCaml values in JavaScript but also when writing the FFI.</p>
<p>Some example of differences are:</p>
<ul>
<li><code>string</code> : In BuckleScript the string is represented as a JavaScript string while in <code>js_of_ocaml</code> it&#39;s a much more involved data structure. </li>
<li><code>array</code>: In BuckleScript the array has the same indexing as a JavaScript array while for <code>js_of_ocaml</code> the index starts at 1.  </li>
<li><code>tuple</code>: In BuckleScript the array has the same indexing as a JavaScript array while for <code>js_of_ocaml</code> the index starts at 1.</li>
</ul>
<p><strong>FFI</strong></p>
<p>Regarding the FFI, BuckleScript favors using only <a href="http://caml.inria.fr/pub/docs/manual-ocaml/extn.html#sec245">attributes</a>; one drawback that we plan to address on the future is that it lacks some expressiveness. </p>
<p><code>js_of_ocaml</code> introduces a very sophisticated and expressive syntax extension, which works great most of the time, but can sometimes generate confusing compiler errors, and be difficult to integrate with existing IDEs and build systems. </p>
<p><strong>Runtime library</strong></p>
<p>BuckleScript runtime library is mostly implemented in OCaml while <code>js_of_ocaml</code> runtime is purely in JavaScript. The difference is actually significant since we believe it reflects how easy it is to write JavaScript code in OCaml using the BuckleScript model (FFI and Runtime representation).</p>
<h2 id="separate-compilation">Separate Compilation</h2>
<p>BuckleScript compiles one OCaml module into one Javascript module. This follows the modern JavaScript development and makes it easier to gradually use OCaml in an existing code base. This is particularly relevant for our use cases for which we plan to implement components in OCaml while the larger application is written in JavaScript. The JavaScript echo system also has plenty of tools and support for modules, making it easy and natural to integrate modules generated by BuckleScript. It also opens the door for supporting <a href="http://webpack.github.io/docs/hot-module-replacement.html">hot module replacement</a> in future.
The module compilation strategy allows more granular compilation and as consequence faster feedback loop during development. </p>
<p><code>js_of_ocaml</code> compiles a whole OCaml program in JavaScript. This makes it easier when the main application is written in OCaml but less natural when integrating OCaml as a component in a larger JavaScript application.</p>
<h2 id="integration-with-existing-ecosystems">Integration with existing ecosystems</h2>
<p>BuckleScript is aware of <code>npm</code> module paths and favor libraries development. In contrast with <code>js_of_ocaml</code>&#39; focus on developing executable. 
BuckleScript does not provide a whole program compilation mode out of the box; it rather delegates this to existing linker/bundler (such as webpack or Google Closure compiler).</p>
<p>When integrating code generated by BuckleScript developers only need to look at the <code>.mli</code> files. BuckleScript respect those interfaces and will only export the functions from the `.mli file. No special code needs to be added to expose OCaml code to the JavaScript.</p>
<p><code>js_of_ocaml</code> requires specific code to export functions OCaml code to the larger JavaScript application.</p>
<h2 id="intrusiveness">Intrusiveness</h2>
<p>The major advantage of <code>js_of_ocaml</code> is that it is non intrusive; you can reuse your existing project setup (build system) and simply convert the bytecode output to JavaScript output as a post-processing step. </p>
<p>With BuckleScript, however, users have to adapt their build system for existing OCaml code base. In BuckleScript, we traded intrusiveness for being able to extract more information from the code. </p>
<p>We think there&#39;s a need for both tools to exist simultaneously. If you have some OCaml code, and your primary motivation is that it should run inside a browser, then <code>js_of_ocaml</code> is a very good choice. However, if you target JavaScript (browser/Node.Js) as the primary backend for your application and care about the integration with the JavaScript environment then we believe BuckleScript can offer a better experience. We also think both projects can help and learn from each other.</p>
<h2 id="performance">Performance</h2>
<p>We have not conducted exhaustive benchmarks yet, however, our initial results show similar performance between <code>js_of_ocaml</code> and BuckleScript (using Google Closure simple optimization level).</p>

                    </div>
                </div>
            </div>
        </div>
        <!-- /#page-content-wrapper -->

    </div>
    <!-- /#wrapper -->

    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
    <!-- Latest compiled and minified JavaScript -->
    <script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
    <script src="js/start.js"></script>


</body>

</html>
